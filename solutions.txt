# Part A:

## Recovered password

[('ceccio', '02361267'), ('bjacobsen', '22005597')]

## Pseudocode for attack

found_passwords = []
for password_length in [1, ..., 8]:
    for each password p of length password_length:
        for user, salt in zip(['ceccio', 'bjacobsen'], ['547750', '980166']):
            if hash(user, p, salt) == known hash
                found_passwords.append((user, p))
The second for loop works by setting max_int = '9'*password_length and then 
iterating through all ints less than this value, adding padding of leading
0's if necessary.

## Worst case running time
The outer for loop is repeated 8 times. The next for loop is 10^n since there are
10 digits and each of the n positions in the password can be one of 10 digits. 
The final for loop is just repeated twice since we have 2 users. 

In total, the running time is 2*(10^8 + 10^7 + ... + 10), which is dominated by 
its largest term, 10^8 (aka 10^n), thus, the algorithm is O(10^n). 

## Discussion of current proposal and suggestions for improvement
    1. Stricter password requirements. Including lower case chars + upper case
       extends running time to O(62^n). Symbols make this larger. Requiring 
       longer passwords will increase n and also extend the running time.
    2. Slower hashing algorithms than sha256 will make it more difficult to 
       go through all cases.


# Part B:

## Discussion of the current scheme
    The implementation of the encryption scheme does provide integrity
    but not authenticity. Therefore, anyone can modify the ciphered message
    without the key and as long as the tag is also updated there is no way
    to tell. 
    In this specific case the 11th byte of the iv can be modified by 0x08
    inorder to change the digit 1 in 12 to a 9 making it 92. This is because
    the $ number is within the first block which is xored with the iv.

## Suggestions for improving the scheme
    I would look into implementing a MAC. This is provided in the Crypto
    api with the verify(mac_tag) function. Or, the scheme could hash the
    key + message together so that the secret key is needed to update the tag.


# Part C:

## Secret code

## Explanation


# EXTRA CREDIT

## Password
    Cheeseisgood!

## Psuedocode for attack

    On each cpu scan (password list / N cpus) passwords:
        if password meets requirements
            hash password
            if hash == known hash
                ->Password has been found